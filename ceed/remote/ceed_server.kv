BoxLayout:
    orientation: 'vertical'
    spacing: '5dp'
    padding: '5dp',
    BoxLayout:
        size_hint_y: None
        height: '40dp'
        spacing: '10dp'
        Spinner:
            id: cam_selection
            values: ['ThorLabs camera', 'Point Gray camera']
            text: 'ThorLabs camera'
            size_hint_max_x: '200dp'
        FlatErrorIndicatorPopup:
            scale_down_color: True
            source: 'flat_alert.png'
            #flat_color: app.theme.accent
            size_hint_x: None
            width: '55dp'
            on_parent: app.error_indicator = self
        Label:
            text: 'Connected' if app.connected else "Disconnected"
            size_hint_x: None
            width: '150dp'
            canvas.before:
                Color:
                    rgba: (0, 153 / 255, 0, 1) if app.connected else (1, 51 / 255, 51 / 255, 1)
                Rectangle:
                    size: self.size
                    pos: self.pos
    ScreenManager:
        size_hint: None, None
        size: tsi_grid.parent.size if self.current == 'ThorLabs camera' else pt_grid.parent.size
        current: cam_selection.text
        Screen:
            name: 'ThorLabs camera'
            size_hint: None, None
            size: tsi_grid.size
            disabled: app.tsi_sdk is None
            GridLayout:
                id: tsi_grid
                size_hint: None, None
                size: self.minimum_size
                cols: 1
                spacing: '2dp'
                BoxLayout:
                    size_hint: None, None
                    size: self.minimum_size
                    spacing: '5dp'
                    SizedLabel:
                        text: 'Camera:'
                    SizedButton:
                        text: 'Refresh'
                        on_release: tsi_cams_spinner.values = app.get_tsi_cams()
                    Spinner:
                        id: tsi_cams_spinner
                        text_autoupdate: True
                        size_hint_x: None
                        width: '60dp'
                    SizedToggleButton:
                        disabled: not tsi_cams_spinner.text
                        text: 'Open' if self.state == 'normal' else 'Close'
                        on_release: app.open_tsi_cam(tsi_cams_spinner.text) if self.state == 'down' else app.close_tsi_cam()
                    SizedToggleButton:
                        disabled: app.tsi_cam is None
                        text: 'Play' if self.state == 'normal' else 'Stop'
                        on_release: app.play_tsi_cam() if self.state == 'down' else app.tsi_cam.send_message('stop')
                    SizedLabel:
                        text: 'Frame: {}'.format(app.num_images_received)
                    SizedLabel:
                        text: 'Frames shared: {}'.format(app.num_images_sent)
                BoxLayout:
                    size_hint: None, None
                    size: self.minimum_size
                    spacing: '5dp'
                    SizedLabel:
                        text: 'Rate ({:0.0f}):'.format(app.estimated_frame_rate)
                    Spinner:
                        disabled: app.tsi_cam is None or app.tsi_cam.playing
                        text_autoupdate: True
                        size_hint_x: None
                        width: '80dp'
                        values: app.tsi_cam.supported_freqs if app.tsi_cam else []
                        text: app.tsi_cam.freq if app.tsi_cam else '20 MHz'
                        on_text: if app.tsi_cam: app.tsi_cam.send_message('setting', ('freq', self.text))
                    SizedLabel:
                        text: 'Taps:'
                    Spinner:
                        disabled: app.tsi_cam is None or app.tsi_cam.playing
                        text_autoupdate: True
                        size_hint_x: None
                        width: '60dp'
                        values: app.tsi_cam.supported_taps if app.tsi_cam else []
                        text: app.tsi_cam.taps if app.tsi_cam else '1'
                        on_text: if app.tsi_cam: app.tsi_cam.send_message('setting', ('taps', self.text))
                    SizedLabel:
                        text: 'Exposure [{}ms, {}ms]:'.format(*(app.tsi_cam.exposure_range if app.tsi_cam else (0, 0)))
                    TextInput:
                        disabled: app.tsi_cam is None
                        id: tsi_value
                        size_hint: None, None
                        size: '80dp', self.minimum_height
                        text: str(app.tsi_cam.exposure_ms) if app.tsi_cam else '0'
                        multiline: False
                        on_focus:
                            if not self.focus and app.tsi_cam: app.tsi_cam.send_message('setting', ('exposure_ms', float(self.text)))
                        input_filter: 'float'
                    Spinner:
                        id: trigger_selector
                        disabled: app.tsi_cam is None or app.tsi_cam.playing
                        text_autoupdate: True
                        size_hint_x: None
                        width: '100dp'
                        values: app.tsi_cam.supported_triggers if app.tsi_cam else []
                        text: app.tsi_cam.trigger_type if app.tsi_cam else 'SW Trigger'
                        on_text: if app.tsi_cam: app.tsi_cam.send_message('setting', ('trigger_type', self.text))
                    TextInput:
                        disabled: app.tsi_cam is None or app.tsi_cam.playing
                        size_hint: None, None
                        size: '80dp', self.minimum_height
                        text: str(app.tsi_cam.trigger_count) if app.tsi_cam else '1'
                        multiline: False
                        on_focus:
                            if not self.focus and app.tsi_cam: app.tsi_cam.send_message('setting', ('trigger_count', int(self.text)))
                        input_filter: 'int'
                BoxLayout:
                    disabled: app.tsi_cam is None
                    size_hint: None, None
                    size: self.minimum_size
                    spacing: '5dp'
                    SizedLabel:
                        text: 'Gain [{}, {}]:'.format(*(app.tsi_cam.gain_range if app.tsi_cam else (0, 0)))
                    TextInput:
                        disabled: self.parent.disabled or not app.tsi_cam.gain_range[1]
                        size_hint: None, None
                        size: '80dp', self.minimum_height
                        text: str(app.tsi_cam.gain) if app.tsi_cam else '0'
                        multiline: False
                        on_focus:
                            if not self.focus and app.tsi_cam: app.tsi_cam.send_message('setting', ('gain', int(self.text)))
                        input_filter: 'int'
                    SizedLabel:
                        text: 'BlackLevel [{}, {}]:'.format(*(app.tsi_cam.black_level_range if app.tsi_cam else (0, 0)))
                    TextInput:
                        disabled: self.parent.disabled or not app.tsi_cam.black_level_range[1]
                        size_hint: None, None
                        size: '80dp', self.minimum_height
                        text: str(app.tsi_cam.black_level) if app.tsi_cam else '0'
                        multiline: False
                        on_focus:
                            if not self.focus and app.tsi_cam: app.tsi_cam.send_message('setting', ('black_level', int(self.text)))
                        input_filter: 'int'
                    SizedLabel:
                        text: 'Frame queue ({}/{}) [1, ...):'.format(app.tsi_cam.num_queued_frames if app.tsi_cam else 0, queue_size.text)
                    TextInput:
                        id: queue_size
                        disabled: app.tsi_cam is None or app.tsi_cam.playing
                        size_hint: None, None
                        size: '80dp', self.minimum_height
                        text: str(app.tsi_cam.frame_queue_size) if app.tsi_cam else '1'
                        multiline: False
                        on_focus:
                            if not self.focus and app.tsi_cam: app.tsi_cam.send_message('setting', ('frame_queue_size', int(self.text)))
                        input_filter: 'int'
                BoxLayout:
                    disabled: app.tsi_cam is None
                    size_hint: None, None
                    size: self.minimum_size
                    spacing: '5dp'
                    SizedLabel:
                        text: 'X bins [{}, {}]:'.format(*(app.tsi_cam.binning_x_range if app.tsi_cam else (0, 0)))
                    TextInput:
                        disabled: app.tsi_cam is None or not app.tsi_cam.binning_x_range[1] or app.tsi_cam.playing
                        size_hint: None, None
                        size: '80dp', self.minimum_height
                        text: str(app.tsi_cam.binning_x) if app.tsi_cam else '0'
                        multiline: False
                        on_focus:
                            if not self.focus and app.tsi_cam: app.tsi_cam.send_message('setting', ('binning_x', int(self.text)))
                        input_filter: 'int'
                    SizedLabel:
                        text: 'Y bins [{}, {}]:'.format(*(app.tsi_cam.binning_y_range if app.tsi_cam else (0, 0)))
                    TextInput:
                        disabled: app.tsi_cam is None or not app.tsi_cam.binning_y_range[1] or app.tsi_cam.playing
                        size_hint: None, None
                        size: '80dp', self.minimum_height
                        text: str(app.tsi_cam.binning_y) if app.tsi_cam else '0'
                        multiline: False
                        on_focus:
                            if not self.focus and app.tsi_cam: app.tsi_cam.send_message('setting', ('binning_y', int(self.text)))
                        input_filter: 'int'
                    SizedLabel:
                        text: 'X [0, {}]:'.format(app.tsi_cam.sensor_size[0] - 1 if app.tsi_cam else 0)
                    TextInput:
                        disabled: app.tsi_cam is None or not app.tsi_cam.sensor_size[0] or app.tsi_cam.playing
                        size_hint: None, None
                        size: '80dp', self.minimum_height
                        text: str(app.tsi_cam.roi_x) if app.tsi_cam else '0'
                        multiline: False
                        on_focus:
                            if not self.focus and app.tsi_cam: app.tsi_cam.send_message('setting', ('roi_x', int(self.text)))
                        input_filter: 'int'
                    SizedLabel:
                        text: 'W [1, {}]:'.format((app.tsi_cam.sensor_size[0] - app.tsi_cam.roi_x) if app.tsi_cam else 0)
                    TextInput:
                        disabled: app.tsi_cam is None or not app.tsi_cam.sensor_size[0] or app.tsi_cam.playing
                        size_hint: None, None
                        size: '80dp', self.minimum_height
                        text: str(app.tsi_cam.roi_width) if app.tsi_cam else '0'
                        multiline: False
                        on_focus:
                            if not self.focus and app.tsi_cam: app.tsi_cam.send_message('setting', ('roi_width', int(self.text)))
                        input_filter: 'int'
                    SizedLabel:
                        text: 'Y [0, {}]:'.format(app.tsi_cam.sensor_size[1] - 1 if app.tsi_cam else 0)
                    TextInput:
                        disabled: app.tsi_cam is None or not app.tsi_cam.sensor_size[1] or app.tsi_cam.playing
                        size_hint: None, None
                        size: '80dp', self.minimum_height
                        text: str(app.tsi_cam.roi_y) if app.tsi_cam else '0'
                        multiline: False
                        on_focus:
                            if not self.focus and app.tsi_cam: app.tsi_cam.send_message('setting', ('roi_y', int(self.text)))
                        input_filter: 'int'
                    SizedLabel:
                        text: 'H [1, {}]:'.format((app.tsi_cam.sensor_size[1] - app.tsi_cam.roi_y) if app.tsi_cam else 0)
                    TextInput:
                        disabled: app.tsi_cam is None or not app.tsi_cam.sensor_size[1] or app.tsi_cam.playing
                        size_hint: None, None
                        size: '80dp', self.minimum_height
                        text: str(app.tsi_cam.roi_height) if app.tsi_cam else '0'
                        multiline: False
                        on_focus:
                            if not self.focus and app.tsi_cam: app.tsi_cam.send_message('setting', ('roi_height', int(self.text)))
                        input_filter: 'int'
                GridLayout:
                    disabled: app.tsi_cam is None
                    rows: 1
                    size_hint_y: None
                    height: self.minimum_height
                    spacing: '5dp'
                    padding: '10dp'
                    UpSlider:
                        id: thor_r_slider
                        size_hint_y: None
                        height: '30dp'
                        on_release: if app.tsi_cam: app.tsi_cam.send_message('setting', ('color_gain', [thor_r_slider.value, thor_g_slider.value, thor_b_slider.value]))
                        min: 0.
                        max: 1.
                        value: 1.
                        canvas.before:
                            Color:
                                rgba: 1, 0, 0, 1
                            Rectangle:
                                size: self.size
                                pos: self.pos
                    UpSlider:
                        id: thor_g_slider
                        size_hint_y: None
                        height: '30dp'
                        on_release: if app.tsi_cam: app.tsi_cam.send_message('setting', ('color_gain', [thor_r_slider.value, thor_g_slider.value, thor_b_slider.value]))
                        min: 0.
                        max: 1.
                        value: 1.
                        canvas.before:
                            Color:
                                rgba: 0, 1, 0, 1
                            Rectangle:
                                size: self.size
                                pos: self.pos
                    UpSlider:
                        id: thor_b_slider
                        size_hint_y: None
                        height: '30dp'
                        on_release: if app.tsi_cam: app.tsi_cam.send_message('setting', ('color_gain', [thor_r_slider.value, thor_g_slider.value, thor_b_slider.value]))
                        min: 0.
                        max: 1.
                        value: 1.
                        canvas.before:
                            Color:
                                rgba: 0, 0, 1, 1
                            Rectangle:
                                size: self.size
                                pos: self.pos
        Screen:
            name: 'Point Gray camera'
            size_hint: None, None
            size: pt_grid.size
            GridLayout:
                id: pt_grid
                cols: 1
                size_hint: None, None
                size: pt_grid.size
                GridLayout:
                    size_hint: None, None
                    size: self.minimum_size
                    height: '50dp'
                    spacing: ['5dp']
                    rows: 1
                    disabled: not app.connected
                    Widget
                    Spinner:
                        id: pt_settings_opt
                        size_hint_x: None
                        width: '100dp'
                        values: ['brightness', 'exposure', 'sharpness', 'hue', 'saturation', 'gamma', 'shutter', 'gain', 'iris', 'frame_rate', 'pan', 'tilt']
                        on_text:
                            app.send_client_cam_request('track_cam_setting', self.text)
                            app.cam_setting = self.text
                        controllable: gui_pt_settings_opt_disable.state == 'normal'
                    SizedToggleButton:
                        id: gui_pt_settings_opt_auto
                        text: 'Auto'
                        on_release: app.send_client_cam_request('set_cam_setting', (pt_settings_opt.text, 'auto', self.state == 'down'))
                        disabled: not pt_settings_opt.controllable
                    SizedButton:
                        id: gui_pt_settings_opt_push
                        text: 'One push'
                        on_release: app.send_client_cam_request('set_cam_setting', (pt_settings_opt.text, 'one_push', True))
                        disabled: not pt_settings_opt.controllable
                    SizedToggleButton:
                        id: gui_pt_settings_opt_disable
                        text: 'Disable'
                        on_release: app.send_client_cam_request('set_cam_setting', (pt_settings_opt.text, 'controllable', self.state == 'normal'))
                    SizedLabel:
                        id: gui_pt_settings_opt_min
                        disabled: not pt_settings_opt.controllable
                    TextInput:
                        id: gui_pt_settings_opt_value
                        size_hint: None, None
                        size: '50dp', self.minimum_height
                        on_focus: if not self.focus: app.send_client_cam_request('set_cam_setting', (pt_settings_opt.text, 'value', float(self.text or 0)))
                        input_filter: 'float'
                        disabled: not pt_settings_opt.controllable
                        multiline: False
                    SizedLabel:
                        id: gui_pt_settings_opt_max
                        disabled: not pt_settings_opt.controllable
                    SizedButton:
                        id: gui_pt_settings_opt_reload
                        text: 'Reload'
                        on_release: app.send_client_cam_request('reload_cam_setting', pt_settings_opt.text)
                    Widget
                UpSlider:
                    id: gui_pt_settings_opt_slider
                    size_hint_y: None
                    height: '50dp'
                    on_release: app.send_client_cam_request('set_cam_setting', (pt_settings_opt.text, 'value', self.value))
                    disabled: not pt_settings_opt.controllable
    BoxLayout:
        size_hint_y: None
        height: self.minimum_height
        spacing: '8dp'
        TextInput:
            size_hint_y: None
            height: self.minimum_height
            multiline: False
            on_text: app.image_save_path = self.text
        SizedLabel:
            text: '_#.tiff'
        Spinner:
            id: compression_option
            text_autoupdate: True
            size_hint_x: None
            width: '60dp'
            values: ['raw', 'lzw', 'zip']
            text: app.image_compression_save
            on_text: app.image_compression_save = self.text
        SizedButton:
            disabled: stream_btn.state == 'down' or app.last_image is None
            text: 'Save'
            on_release: app.save_last_image()
        SizedToggleButton:
            id: stream_btn
            text: 'Save sequence ({})'.format(app.image_queue_len)
            on_state: app.stream_image_save = self.state == 'down'
    BufferImage:
        canvas.before:
            Color:
                rgba: [0, 0, 0, 1]
            Rectangle:
                pos: self.pos
                size: self.size
        id: img
        auto_bring_to_front: False
        available_size: self.size

        do_scale: True
        do_translation: True, True
        do_rotation: True

<ScreenGrid@Screen+GridLayout>
<SizedLabel@Label>:
    size_hint: None, None
    size: self.texture_size
    padding: '5dp', '5dp'
<SizedButton@Button>:
    size_hint: None, None
    size: self.texture_size
    padding: '5dp', '5dp'
<SizedToggleButton@ToggleButton>:
    size_hint: None, None
    size: self.texture_size
    padding: '5dp', '5dp'
